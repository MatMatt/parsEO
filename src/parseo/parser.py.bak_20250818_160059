# src/parseo/parser.py
from __future__ import annotations

import json
import re
from dataclasses import dataclass
from importlib import resources
from jsonschema import validate, ValidationError

SCHEMAS_ROOT = "schemas"


@dataclass
class ParseResult:
    fields: dict
    schema_path: str | None
    valid: bool
    match_family: str | None = None


def _iter_schema_paths(package: str):
    root = resources.files(package).joinpath(SCHEMAS_ROOT)
    if not root.exists():
        return
    for p in root.rglob("*.json"):
        if p.is_file():
            yield p


def _find_schema_by_hints(package: str, *, product: str | None = None):
    family_patterns = {
        "S1": (r"(^|/)sentinel/", r"^sentinel1_.*\.json$"),
        "S2": (r"(^|/)sentinel/", r"^sentinel2_.*\.json$"),
        "LANDSAT": (r"(^|/)landsat/", r"^landsat[0-9]_.*\.json$"),
    }

    if product is None:
        return None

    hint = product.upper()
    if hint.startswith("SENTINEL-1"):
        hint = "S1"
    elif hint.startswith("SENTINEL-2"):
        hint = "S2"
    elif hint.startswith("LANDSAT"):
        hint = "LANDSAT"
    elif hint.startswith("S1"):
        hint = "S1"
    elif hint.startswith("S2"):
        hint = "S2"

    fam = family_patterns.get(hint)
    if not fam:
        return None

    subdir_re, filename_re = fam
    subdir_rx = re.compile(subdir_re.replace("/", r"[\\/]"))
    fname_rx = re.compile(filename_re, re.IGNORECASE)

    for p in _iter_schema_paths(__package__):
        rel = str(p)
        if subdir_rx.search(rel) and fname_rx.search(p.name):
            return p
    return None


def _load_json_from_path(path_obj):
    with path_obj.open("r", encoding="utf-8") as f:
        return json.load(f)


def _try_validate(name: str, schema_dict: dict) -> bool:
    try:
        validate(instance={"name": name}, schema=schema_dict)
        return True
    except ValidationError:
        return False


def _extract_fields(name: str) -> dict:
    """
    Extract minimal fields needed by tests from the filename prefix.

    Examples:
      S2B_MSIL2A_20241123T224759_... -> mission=S2B, instrument_processing=MSIL2A
      S1A_IW_SLC__1SDV_20250105T...  -> mission=S1A, instrument_mode=IW
    """
    fields: dict[str, str] = {}

    # Common mission code first token (e.g., S2B, S1A)
    m = re.match(r"^([A-Z0-9]{3})_", name)
    if m:
        fields["mission"] = m.group(1)

    # Sentinel-2: mission 'S2A' or 'S2B' then instrument/processing (e.g., MSIL2A)
    m_s2 = re.match(r"^(S2[AB])_([A-Z0-9]+)_", name)
    if m_s2:
        fields.setdefault("mission", m_s2.group(1))
        fields["instrument_processing"] = m_s2.group(2)
        return fields  # done

    # Sentinel-1: mission 'S1A' or 'S1B' then instrument mode (e.g., IW)
    m_s1 = re.match(r"^(S1[AB])_([A-Z]{2,3})_", name)
    if m_s1:
        fields.setdefault("mission", m_s1.group(1))
        fields["instrument_mode"] = m_s1.group(2)
        return fields  # done

    # If neither matched, just return what we have (mission if present)
    return fields

def parse_auto(name: str) -> ParseResult:
    pkg = __package__  # "parseo"

    # Determine quick family hint
    u = name.upper()
    if u.startswith(("S1", "SENTINEL-1")):
        product_hint = "S1"
    elif u.startswith(("S2", "SENTINEL-2")):
        product_hint = "S2"
    elif u.startswith("LANDSAT"):
        product_hint = "LANDSAT"
    else:
        product_hint = None

    # Try hinted schema first
    hinted = _find_schema_by_hints(pkg, product=product_hint)
    if hinted and hinted.exists():
        try:
            schema = _load_json_from_path(hinted)
            if _try_validate(name, schema):
                return ParseResult(
                    fields=_extract_fields(name),
                    schema_path=str(hinted),
                    valid=True,
                    match_family=product_hint,
                )
        except Exception:
            # Fall through to brute-force if schema unreadable
            pass

    # Fallback: brute-force across all schemas
    candidates = list(_iter_schema_paths(pkg))
    if not candidates:
        raise FileNotFoundError(f"No schemas packaged under {pkg}/{SCHEMAS_ROOT}.")

    first_error = None
    for p in candidates:
        try:
            schema = _load_json_from_path(p)
        except Exception as e:
            if first_error is None:
                first_error = e
            continue
        if _try_validate(name, schema):
            return ParseResult(
                fields=_extract_fields(name),
                schema_path=str(p),
                valid=True,
                match_family=product_hint,
            )

    # Nothing matched
    raise RuntimeError(
        "No schema matched the provided name. "
        "Ensure appropriate schemas exist under schemas/**/*.json"
    )
